const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
require('dotenv').config();

const db = require('./db'); // Import database connection

const app = express();
const PORT = process.env.PORT || 5000;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';

// Middleware
app.use(cors());
app.use(express.json());
app.use('/uploads', express.static('uploads'));

// Create uploads directory if it doesn't exist
if (!fs.existsSync('uploads')) {
  fs.mkdirSync('uploads');
}

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});
const upload = multer({ storage });

// Middleware to verify JWT token
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.sendStatus(401);
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

// Middleware to check if user is admin
const requireAdmin = (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Admin access required' });
  }
  next();
};

// ============ AUTH ENDPOINTS ============

// Register new user
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, username, password } = req.body;
    
    // Check if user exists
    const [existingUsers] = await db.query(
      'SELECT id FROM users WHERE username = ? OR email = ?',
      [username, email]
    );
    
    if (existingUsers.length > 0) {
      return res.status(400).json({ error: 'Username or email already exists' });
    }
    
    // Hash password
	console.log(req);
    const hashedPassword = await bcrypt.hash(password, parseInt(5, 10));
	console.log("hello!");
    
    // Create user
    const [result] = await db.query(
      'INSERT INTO users (email, username, password, role, name, online, image) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [email, username, hashedPassword, 'user', username, true, '']
    );
    
    const userId = result.insertId;
    
    // Generate token
    const token = jwt.sign({ id: userId, username, role: 'user' }, JWT_SECRET);
    
    res.json({
      token,
      user: { id: userId, email, username, role: 'user', name: username, online: true, image: '' }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Get user from database
    const [users] = await db.query(
      'SELECT * FROM users WHERE username = ?',
      [username]
    );
    
    if (users.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const user = users[0];
    
    // Verify password
    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Update online status
    await db.query('UPDATE users SET online = true WHERE id = ?', [user.id]);
    
    // Generate token
    const token = jwt.sign({ id: user.id, username: user.username, role: user.role }, JWT_SECRET);
    
    res.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        role: user.role,
        name: user.name,
        online: true,
        image: user.image
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get current user
app.get('/api/auth/me', authenticateToken, async (req, res) => {
  try {
    const [users] = await db.query(
      'SELECT id, email, username, role, name, online, image FROM users WHERE id = ?',
      [req.user.id]
    );
    
    if (users.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json(users[0]);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update profile
app.put('/api/auth/profile', authenticateToken, async (req, res) => {
  try {
    const { name, image } = req.body;
    await db.query(
      'UPDATE users SET name = ?, image = ? WHERE id = ?',
      [name, image, req.user.id]
    );
    res.json({ message: 'Profile updated' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ PROJECT ENDPOINTS ============

// Get all projects for user
app.get('/api/projects', authenticateToken, async (req, res) => {
  try {
    let query;
    let params;
    
    if (req.user.role === 'admin') {
      // Admin sees all projects
      query = `
        SELECT p.*, COUNT(DISTINCT pu.user_id) as teamCount 
        FROM projects p 
        LEFT JOIN project_users pu ON p.id = pu.project_id 
        GROUP BY p.id
      `;
      params = [];
    } else {
      // Users see only their projects
      query = `
        SELECT p.*, COUNT(DISTINCT pu2.user_id) as teamCount 
        FROM projects p 
        JOIN project_users pu ON p.id = pu.project_id 
        LEFT JOIN project_users pu2 ON p.id = pu2.project_id
        WHERE pu.user_id = ? 
        GROUP BY p.id
      `;
      params = [req.user.id];
    }
    
    const [projects] = await db.query(query, params);
    res.json(projects);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get single project
app.get('/api/projects/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check if user has access to project
    if (req.user.role !== 'admin') {
      const [access] = await db.query(
        'SELECT * FROM project_users WHERE project_id = ? AND user_id = ?',
        [id, req.user.id]
      );
      
      if (access.length === 0) {
        return res.status(403).json({ error: 'Access denied' });
      }
    }
    
    // Get project details
    const [projects] = await db.query(
      'SELECT * FROM projects WHERE id = ?',
      [id]
    );
    
    if (projects.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    // Get channels
    const [channels] = await db.query(
      'SELECT * FROM channels WHERE project_id = ?',
      [id]
    );
    
    res.json({ ...projects[0], channels });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create project (admin only)
app.post('/api/projects', authenticateToken, requireAdmin, async (req, res) => {
  const connection = await db.getConnection();
  try {
    await connection.beginTransaction();
    
    const { title, description, image } = req.body;
    
    // Create project
    const [result] = await connection.query(
      'INSERT INTO projects (title, description, image, created_by) VALUES (?, ?, ?, ?)',
      [title, description, image || '', req.user.id]
    );
    
    const projectId = result.insertId;
    
    // Add creator as team member
    await connection.query(
      'INSERT INTO project_users (project_id, user_id) VALUES (?, ?)',
      [projectId, req.user.id]
    );
    
    // Create default channel
    await connection.query(
      'INSERT INTO channels (project_id, name) VALUES (?, ?)',
      [projectId, 'general']
    );
    
    // Create default documentation sections
    const defaultSections = [
      ['Game Overview', ''],
      ['Game Mechanics', ''],
      ['Story & Lore', ''],
      ['Art Direction', ''],
      ['Technical Specifications', ''],
      ['Development Timeline', '']
    ];
    
    for (const [section, content] of defaultSections) {
      await connection.query(
        'INSERT INTO documentation (project_id, section, content) VALUES (?, ?, ?)',
        [projectId, section, content]
      );
    }
    
    await connection.commit();
    
    res.json({ 
      id: projectId, 
      title, 
      description, 
      image: image || '',
      teamCount: 1
    });
  } catch (error) {
    await connection.rollback();
    res.status(500).json({ error: error.message });
  } finally {
    connection.release();
  }
});

// Update project (admin only)
app.put('/api/projects/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, image } = req.body;
    
    await db.query(
      'UPDATE projects SET title = ?, description = ?, image = ? WHERE id = ?',
      [title, description, image || '', id]
    );
    
    res.json({ message: 'Project updated' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Delete project (admin only)
app.delete('/api/projects/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    await db.query('DELETE FROM projects WHERE id = ?', [id]);
    res.json({ message: 'Project deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ TASK ENDPOINTS ============

// Get tasks for project
app.get('/api/projects/:projectId/tasks', authenticateToken, async (req, res) => {
  try {
    const { projectId } = req.params;
    
    // Get tasks
    const [tasks] = await db.query(
      'SELECT * FROM tasks WHERE project_id = ? ORDER BY created_at DESC',
      [projectId]
    );
    
    // Get tags for each task
    const taskIds = tasks.map(t => t.id);
    if (taskIds.length > 0) {
      const [tags] = await db.query(
        'SELECT * FROM task_tags WHERE task_id IN (?)',
        [taskIds]
      );
      
      // Group tags by task
      const tagsByTask = {};
      tags.forEach(tag => {
        if (!tagsByTask[tag.task_id]) {
          tagsByTask[tag.task_id] = [];
        }
        tagsByTask[tag.task_id].push(tag.tag);
      });
      
      // Add tags to tasks
      tasks.forEach(task => {
        task.tags = tagsByTask[task.id] || [];
      });
    }
    
    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create task
app.post('/api/projects/:projectId/tasks', authenticateToken, async (req, res) => {
  const connection = await db.getConnection();
  try {
    await connection.beginTransaction();
    
    const { projectId } = req.params;
    const { title, description, priority, tags } = req.body;
    
    // Create task
    const [result] = await connection.query(
      'INSERT INTO tasks (project_id, title, description, status, priority, created_by) VALUES (?, ?, ?, ?, ?, ?)',
      [projectId, title, description || '', 'todo', priority || 'medium', req.user.id]
    );
    
    const taskId = result.insertId;
    
    // Add tags
    if (tags && tags.length > 0) {
      for (const tag of tags) {
        await connection.query(
          'INSERT INTO task_tags (task_id, tag) VALUES (?, ?)',
          [taskId, tag]
        );
      }
    }
    
    await connection.commit();
    
    res.json({ 
      id: taskId, 
      title, 
      description: description || '', 
      status: 'todo', 
      priority: priority || 'medium', 
      tags: tags || [] 
    });
  } catch (error) {
    await connection.rollback();
    res.status(500).json({ error: error.message });
  } finally {
    connection.release();
  }
});

// Update task
app.put('/api/tasks/:id', authenticateToken, async (req, res) => {
  const connection = await db.getConnection();
  try {
    await connection.beginTransaction();
    
    const { id } = req.params;
    const { title, description, status, priority, tags } = req.body;
    
    // Update task
    const updateFields = [];
    const updateValues = [];
    
    if (title !== undefined) {
      updateFields.push('title = ?');
      updateValues.push(title);
    }
    if (description !== undefined) {
      updateFields.push('description = ?');
      updateValues.push(description);
    }
    if (status !== undefined) {
      updateFields.push('status = ?');
      updateValues.push(status);
    }
    if (priority !== undefined) {
      updateFields.push('priority = ?');
      updateValues.push(priority);
    }
    
    if (updateFields.length > 0) {
      updateValues.push(id);
      await connection.query(
        `UPDATE tasks SET ${updateFields.join(', ')} WHERE id = ?`,
        updateValues
      );
    }
    
    // Update tags if provided
    if (tags !== undefined) {
      // Delete existing tags
      await connection.query('DELETE FROM task_tags WHERE task_id = ?', [id]);
      
      // Add new tags
      for (const tag of tags) {
        await connection.query(
          'INSERT INTO task_tags (task_id, tag) VALUES (?, ?)',
          [id, tag]
        );
      }
    }
    
    await connection.commit();
    res.json({ message: 'Task updated' });
  } catch (error) {
    await connection.rollback();
    res.status(500).json({ error: error.message });
  } finally {
    connection.release();
  }
});

// Delete task
app.delete('/api/tasks/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    await db.query('DELETE FROM tasks WHERE id = ?', [id]);
    res.json({ message: 'Task deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ DOCUMENTATION ENDPOINTS ============

// Get documentation for project
app.get('/api/projects/:projectId/documentation', authenticateToken, async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const [docs] = await db.query(
      'SELECT section, content FROM documentation WHERE project_id = ?',
      [projectId]
    );
    
    // Convert to object format
    const documentation = {};
    docs.forEach(doc => {
      documentation[doc.section] = doc.content;
    });
    
    res.json(documentation);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create/Update documentation section
app.post('/api/projects/:projectId/documentation', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { projectId } = req.params;
    const { section, content } = req.body;
    
    await db.query(
      'INSERT INTO documentation (project_id, section, content) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE content = VALUES(content)',
      [projectId, section, content]
    );
    
    res.json({ message: 'Documentation updated' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Delete documentation section
app.delete('/api/projects/:projectId/documentation/:section', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { projectId, section } = req.params;
    
    await db.query(
      'DELETE FROM documentation WHERE project_id = ? AND section = ?',
      [projectId, decodeURIComponent(section)]
    );
    
    res.json({ message: 'Section deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ CHAT ENDPOINTS ============

// Get messages for channel
app.get('/api/projects/:projectId/channels/:channelId/messages', authenticateToken, async (req, res) => {
  try {
    const { projectId, channelId } = req.params;
    
    const [messages] = await db.query(
      `SELECT m.*, u.name as userName, u.username, u.role, u.image 
       FROM messages m 
       JOIN users u ON m.user_id = u.id 
       WHERE m.project_id = ? AND m.channel_id = ? 
       ORDER BY m.timestamp`,
      [projectId, channelId]
    );
    
    res.json(messages);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Send message
app.post('/api/projects/:projectId/channels/:channelId/messages', authenticateToken, async (req, res) => {
  try {
    const { projectId, channelId } = req.params;
    const { text } = req.body;
    
    const [result] = await db.query(
      'INSERT INTO messages (project_id, channel_id, user_id, text) VALUES (?, ?, ?, ?)',
      [projectId, channelId, req.user.id, text]
    );
    
    res.json({ 
      id: result.insertId, 
      userId: req.user.id, 
      text, 
      timestamp: new Date(), 
      channel: channelId 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ TEAM ENDPOINTS ============

// Get project team members
app.get('/api/projects/:projectId/team', authenticateToken, async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const [team] = await db.query(
      `SELECT u.id, u.email, u.username, u.role, u.name, u.online, u.image 
       FROM users u 
       JOIN project_users pu ON u.id = pu.user_id 
       WHERE pu.project_id = ?`,
      [projectId]
    );
    
    res.json(team);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Add team member
app.post('/api/projects/:projectId/team/:userId', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { projectId, userId } = req.params;
    
    // Check if already a member
    const [existing] = await db.query(
      'SELECT * FROM project_users WHERE project_id = ? AND user_id = ?',
      [projectId, userId]
    );
    
    if (existing.length > 0) {
      return res.status(400).json({ error: 'User is already a team member' });
    }
    
    await db.query(
      'INSERT INTO project_users (project_id, user_id) VALUES (?, ?)',
      [projectId, userId]
    );
    
    res.json({ message: 'Team member added' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Remove team member
app.post('/api/projects/:projectId/team/:userId', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { projectId, userId } = req.params;
    
    // Don't allow removing the last admin
    const [admins] = await db.query(
      `SELECT COUNT(*) as count 
       FROM project_users pu 
       JOIN users u ON pu.user_id = u.id 
       WHERE pu.project_id = ? AND u.role = 'admin'`,
      [projectId]
    );
    
    if (admins[0].count <= 1) {
      const [user] = await db.query('SELECT role FROM users WHERE id = ?', [userId]);
      if (user[0]?.role === 'admin') {
        return res.status(400).json({ error: 'Cannot remove the last admin from the project' });
      }
    }
    
    await db.query(
      'DELETE FROM project_users WHERE project_id = ? AND user_id = ?',
      [projectId, userId]
    );
    
    res.json({ message: 'Team member removed' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get all users (admin only)
app.get('/api/users', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [users] = await db.query(
      'SELECT id, email, username, role, name, online, image FROM users'
    );
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// File upload endpoint
app.post('/api/upload', authenticateToken, upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  res.json({ url: `/uploads/${req.file.filename}` });
});

// Create channels
app.post('/api/projects/:projectId/channels', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { projectId } = req.params;
    const { name } = req.body;
    
    const [result] = await db.query(
      'INSERT INTO channels (project_id, name) VALUES (?, ?)',
      [projectId, name]
    );
    
    res.json({ id: result.insertId, name });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// WebSocket support for real-time features (optional)
// You can add Socket.io here for real-time chat and notifications

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
    